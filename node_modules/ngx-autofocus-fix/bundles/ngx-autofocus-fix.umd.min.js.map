{"version":3,"sources":["ng://ngx-autofocus-fix/lib/autofocus-fix-config.ts","ng://ngx-autofocus-fix/lib/utils.ts","ng://ngx-autofocus-fix/lib/autofocus-fix.directive.ts","ng://ngx-autofocus-fix/lib/autofocus-fix.module.ts","ng://ngx-autofocus-fix/lib/no-autofocus-fix-config.error.ts"],"names":["AutofocusFixConfig","config","_this","this","async","smartEmptyCheck","triggerDetectChanges","keys","filter","name","undefined","forEach","normalizeInputAsBoolean","value","isNaN","Array","length","Object","AutofocusFixDirective","$er","$cdr","$document","$config","wasInitialized","localConfig","autofocusEnabled","element","nativeElement","prototype","ngOnChanges","changes","normalizeLocalConfigItem","autofocusFixAsync","autofocusFixSmartEmptyCheck","autofocusFixTriggerDetectChanges","ngOnInit","focus","console","warn","key","local","autofocus","ngAfterContentInit","checkFocus","setTimeout","checkFocusInternal","bind","amIFocused","detectChanges","defineProperty","activeElement","configKey","change","currentValue","Directive","args","selector","ElementRef","ChangeDetectorRef","Document","decorators","type","Inject","DOCUMENT","Input","configFactory","options","AutofocusFixOptionsInternalToken","InjectionToken","AutofocusFixModule","configName","Error","moduleName","noAutofocusFixConfigError","forRoot","ngModule","providers","provide","useValue","useFactory","deps","NgModule","declarations","exports","Optional"],"mappings":"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","sourcesContent":["export class AutofocusFixConfig {\n  public static readonly keys: (keyof AutofocusFixConfig)[] = ['async', 'smartEmptyCheck', 'triggerDetectChanges'];\n\n  public constructor(config: AutofocusFixOptions) {\n    AutofocusFixConfig.keys\n      .filter(name => config[name] !== undefined)\n      // @ts-ignore\n      .forEach(name => this[name] = config[name]);\n  }\n\n  /**\n   * In case `true` .focus() events will be wrapped by `setTimeout(() => ...)`.\n   *\n   * Notice:\n   * I'm not sure that the action is a good practice, however this ability added because of next issues:\n   * - https://github.com/korniychuk/angular-autofocus-fix/issues/1\n   * - https://github.com/spirosikmd/angular2-focus/issues/46\n   */\n  public readonly async: boolean = false;\n  /**\n   * In case `true`: treat an empty string, an empty array and an empty object as a falsy value.\n   * In case `false`(default): each of these values treats as truthy.\n   */\n  public readonly smartEmptyCheck: boolean = false;\n  /**\n   * In case `true`: trigger {@link ChangeDetectorRef.detectChanges}() after {@link HTMLElement.focus}().\n   *\n   * This is helpful in the case when the HTMLElement to which {@link AutofocusFixDirective} added\n   * wrapped by another directive/component that has some binding related to focus of the element.\n   * In this case without enabling .triggerChangeDetection option Angular throws ExpressionChangedAfterItHasBeenCheckedError.\n   *\n   * A striking example is the <mat-form-field> from the Angular Material that wraps <input> control.\n   */\n  public readonly triggerDetectChanges: boolean = false;\n}\n\nexport type AutofocusFixOptions = Partial<AutofocusFixConfig>;\n","export type MutablePartial<T> = { -readonly [K in keyof T]+?: T[K] };\nexport type Mutable<T> = { -readonly [K in keyof T]: T[K] };\n\nexport function normalizeInputAsBoolean(value: any, smartEmptyCheck: boolean = false): boolean {\n  const isFalse = value === false\n               || value === null\n               || value === undefined\n               || value === 0\n               || value === 'false'\n               || value === 'null'\n               || value === 'undefined'\n               || value === '0'\n               || (typeof value === 'number' && isNaN(value))\n               || value === 'NaN'\n               || smartEmptyCheck && (\n                       value === '' // Notice: opposite default behavior!\n                    || value instanceof Array && !value.length\n                    || value !== null && typeof value === 'object' && !Object.keys(value).length\n                  );\n\n  return !isFalse;\n}\n","import {\n  AfterContentInit,\n  ChangeDetectorRef,\n  Directive,\n  ElementRef,\n  Inject,\n  Input,\n  OnChanges, OnInit,\n  SimpleChange,\n} from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n\nimport { normalizeInputAsBoolean, MutablePartial, Mutable } from './utils';\nimport { AutofocusFixConfig } from './autofocus-fix-config';\n\n// @todo: check configuration\n\n/**\n * ## Ways to turn off autofocus: any js-falsely value, except empty string\n *\n *     <!-- with data binding -->\n *     <input [autofocus]=\"\"> <!-- undefined value -->\n *     <input [autofocus]=\"undefined\">\n *     <input [autofocus]=\"false\">\n *     <input [autofocus]=\"null\">\n *     <input [autofocus]=\"0\">\n *     <input [autofocus]=\"NaN\">\n *\n *     <!-- without data binding -->\n *     <input autofocus=\"undefined\">\n *     <input autofocus=\"false\">\n *     <input autofocus=\"null\">\n *     <input autofocus=\"0\">\n *     <input autofocus=\"NaN\">\n *\n *     <input> <!-- disabled by default -->\n *\n *\n * ## Ways to enable autofocus: any js-true value and empty string\n *\n *     <!-- empty string will enable autofocus, this is default html behavior -->\n *     <input [autofocus]=\"''\">\n *     <input autofocus=\"\">\n *     <input autofocus>\n *\n *     <input [autofocus]=\"true\">\n *     <input autofocus=\"true\">\n *\n *     <input [autofocus]=\"'any other values'\">\n *\n * @dynamic\n * Notice: @dynamic used for correctly Document inject\n *         https://github.com/angular/angular/issues/20351\n */\n@Directive({\n  selector: '[autofocus]',\n})\nexport class AutofocusFixDirective implements OnChanges, OnInit, AfterContentInit {\n\n  /** Raw value. Always have default value: '' */\n  @Input()\n  public autofocus: any;\n\n  /** @see {@link AutofocusFixConfig.smartEmptyCheck} */\n  @Input()\n  public autofocusFixSmartEmptyCheck?: boolean | any;\n\n  /** @see {@link AutofocusFixConfig.triggerDetectChanges} */\n  @Input()\n  public autofocusFixTriggerDetectChanges?: boolean | any;\n\n  /** @see {@link AutofocusFixConfig.async} */\n  @Input()\n  public autofocusFixAsync?: boolean | any;\n\n  private wasInitialized = false;\n  /** Notice: protected for unit testing */\n  protected localConfig: MutablePartial<AutofocusFixConfig> = {};\n  private config!: Mutable<AutofocusFixConfig>;\n  private autofocusEnabled = false;\n  private readonly element: HTMLElement;\n\n  public constructor(\n    $er: ElementRef,\n    private readonly $cdr: ChangeDetectorRef,\n    @Inject(DOCUMENT)\n    private readonly $document: Document,\n    private readonly $config: AutofocusFixConfig,\n  ) {\n    this.element = $er.nativeElement;\n  }\n\n  public ngOnChanges(changes: { [key in keyof AutofocusFixDirective]?: SimpleChange }): void {\n    // Autofocus works only once. No need to do the initialization on each change detection cycle.\n    if (this.wasInitialized) { return; }\n\n    this.normalizeLocalConfigItem('async', changes.autofocusFixAsync);\n    this.normalizeLocalConfigItem('smartEmptyCheck', changes.autofocusFixSmartEmptyCheck);\n    this.normalizeLocalConfigItem('triggerDetectChanges', changes.autofocusFixTriggerDetectChanges);\n  }\n\n  public ngOnInit(): void {\n    if (!this.element.focus) {\n      return console.warn(\n        'AutofocusFixDirective: There is no .focus() method on the element: %O',\n        this.element,\n      );\n    }\n\n    this.config = {} as AutofocusFixConfig;\n    AutofocusFixConfig.keys.forEach(key => {\n      const local = this.localConfig[key];\n      this.config[key] = local !== undefined ? local : this.$config[key];\n    });\n\n    this.autofocusEnabled = normalizeInputAsBoolean(this.autofocus, this.config.smartEmptyCheck);\n  }\n\n  public ngAfterContentInit(): void {\n    this.wasInitialized = true;\n    if (!this.element.focus) { return; }\n\n    this.checkFocus();\n  }\n\n  private checkFocus(): void {\n    this.config.async ? setTimeout(this.checkFocusInternal.bind(this)) : this.checkFocusInternal();\n  }\n\n  private checkFocusInternal(): void {\n    if (!this.autofocusEnabled || this.amIFocused) { return; }\n\n    this.element.focus();\n    if (this.config.triggerDetectChanges) {\n      this.$cdr.detectChanges();\n    }\n  }\n\n  private get amIFocused(): boolean {\n    return this.$document.activeElement === this.element;\n  }\n\n  private normalizeLocalConfigItem(configKey: keyof AutofocusFixConfig, change?: SimpleChange): void {\n    if (change) {\n      this.localConfig[configKey] = normalizeInputAsBoolean(change.currentValue);\n    }\n  }\n\n}\n","import { InjectionToken, ModuleWithProviders, NgModule, Optional } from '@angular/core';\n\nimport { AutofocusFixConfig, AutofocusFixOptions } from './autofocus-fix-config';\nimport { AutofocusFixDirective } from './autofocus-fix.directive';\nimport { noAutofocusFixConfigError } from './no-autofocus-fix-config.error';\n\n// Exists for AoT support\nexport function configFactory(options: AutofocusFixOptions) {\n  return new AutofocusFixConfig(options);\n}\n// Exists for AoT support\nconst AutofocusFixOptionsInternalToken = new InjectionToken('AutofocusFixOptions');\n\n@NgModule({\n  declarations: [AutofocusFixDirective],\n  exports: [AutofocusFixDirective]\n})\nexport class AutofocusFixModule {\n\n  public constructor(@Optional() $config: AutofocusFixConfig) {\n    if (!$config) {\n      noAutofocusFixConfigError();\n    }\n  }\n\n  public static forRoot(options: AutofocusFixOptions = {}): ModuleWithProviders {\n\n    return {\n      ngModule: AutofocusFixModule,\n      providers: [\n        {\n          provide: AutofocusFixOptionsInternalToken,\n          useValue: options,\n        },\n        {\n          provide: AutofocusFixConfig,\n          useFactory: configFactory,\n          deps: [AutofocusFixOptionsInternalToken],\n        },\n      ],\n    };\n  }\n\n}\n","export function noAutofocusFixConfigError() {\n  const moduleName = 'AutofocusFixModule';\n  const configName = 'AutofocusFixConfig';\n\n  throw new Error(`${ moduleName }: Can't inject ${ configName }.\n\n    Option 1: Use .forRoot() when you importing the module:\n              Do it in case you import ${ moduleName } to the root module of your application.\n\n    @NgModule({\n      ...\n      imports: [\n        ...\n        ${ moduleName }.forRoot(),     // <--- new code\n      ],\n      ...\n    })\n    export class AppModule {}\n\n\n    Option 2: Provide ${ configName } manually providing ${ configName }:\n              Do it in case you want to provide specific config to the one of your lazy loadable modules.\n\n    @NgModule({\n      ...\n      providers: [\n        ...\n        {                                               // <--- new code\n          provide: ${ configName }                   // <---\n          useValue: new ${configName}({ ... }),    // <---\n        },                                              // <---\n      ],\n      ...\n    })\n    export class AppModule {}\n  `);\n}\n"]}