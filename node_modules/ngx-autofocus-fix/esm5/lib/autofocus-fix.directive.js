/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectorRef, Directive, ElementRef, Inject, Input, } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { normalizeInputAsBoolean } from './utils';
import { AutofocusFixConfig } from './autofocus-fix-config';
// @todo: check configuration
/**
 * ## Ways to turn off autofocus: any js-falsely value, except empty string
 *
 *     <!-- with data binding -->
 *     <input [autofocus]=""> <!-- undefined value -->
 *     <input [autofocus]="undefined">
 *     <input [autofocus]="false">
 *     <input [autofocus]="null">
 *     <input [autofocus]="0">
 *     <input [autofocus]="NaN">
 *
 *     <!-- without data binding -->
 *     <input autofocus="undefined">
 *     <input autofocus="false">
 *     <input autofocus="null">
 *     <input autofocus="0">
 *     <input autofocus="NaN">
 *
 *     <input> <!-- disabled by default -->
 *
 *
 * ## Ways to enable autofocus: any js-true value and empty string
 *
 *     <!-- empty string will enable autofocus, this is default html behavior -->
 *     <input [autofocus]="''">
 *     <input autofocus="">
 *     <input autofocus>
 *
 *     <input [autofocus]="true">
 *     <input autofocus="true">
 *
 *     <input [autofocus]="'any other values'">
 *
 * \@dynamic
 * Notice: \@dynamic used for correctly Document inject
 *         https://github.com/angular/angular/issues/20351
 */
var AutofocusFixDirective = /** @class */ (function () {
    function AutofocusFixDirective($er, $cdr, $document, $config) {
        this.$cdr = $cdr;
        this.$document = $document;
        this.$config = $config;
        this.wasInitialized = false;
        /**
         * Notice: protected for unit testing
         */
        this.localConfig = {};
        this.autofocusEnabled = false;
        this.element = $er.nativeElement;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    AutofocusFixDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        // Autofocus works only once. No need to do the initialization on each change detection cycle.
        if (this.wasInitialized) {
            return;
        }
        this.normalizeLocalConfigItem('async', changes.autofocusFixAsync);
        this.normalizeLocalConfigItem('smartEmptyCheck', changes.autofocusFixSmartEmptyCheck);
        this.normalizeLocalConfigItem('triggerDetectChanges', changes.autofocusFixTriggerDetectChanges);
    };
    /**
     * @return {?}
     */
    AutofocusFixDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.element.focus) {
            return console.warn('AutofocusFixDirective: There is no .focus() method on the element: %O', this.element);
        }
        this.config = (/** @type {?} */ ({}));
        AutofocusFixConfig.keys.forEach((/**
         * @param {?} key
         * @return {?}
         */
        function (key) {
            /** @type {?} */
            var local = _this.localConfig[key];
            _this.config[key] = local !== undefined ? local : _this.$config[key];
        }));
        this.autofocusEnabled = normalizeInputAsBoolean(this.autofocus, this.config.smartEmptyCheck);
    };
    /**
     * @return {?}
     */
    AutofocusFixDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.wasInitialized = true;
        if (!this.element.focus) {
            return;
        }
        this.checkFocus();
    };
    /**
     * @private
     * @return {?}
     */
    AutofocusFixDirective.prototype.checkFocus = /**
     * @private
     * @return {?}
     */
    function () {
        this.config.async ? setTimeout(this.checkFocusInternal.bind(this)) : this.checkFocusInternal();
    };
    /**
     * @private
     * @return {?}
     */
    AutofocusFixDirective.prototype.checkFocusInternal = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.autofocusEnabled || this.amIFocused) {
            return;
        }
        this.element.focus();
        if (this.config.triggerDetectChanges) {
            this.$cdr.detectChanges();
        }
    };
    Object.defineProperty(AutofocusFixDirective.prototype, "amIFocused", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.$document.activeElement === this.element;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} configKey
     * @param {?=} change
     * @return {?}
     */
    AutofocusFixDirective.prototype.normalizeLocalConfigItem = /**
     * @private
     * @param {?} configKey
     * @param {?=} change
     * @return {?}
     */
    function (configKey, change) {
        if (change) {
            this.localConfig[configKey] = normalizeInputAsBoolean(change.currentValue);
        }
    };
    AutofocusFixDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[autofocus]',
                },] }
    ];
    /** @nocollapse */
    AutofocusFixDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: AutofocusFixConfig }
    ]; };
    AutofocusFixDirective.propDecorators = {
        autofocus: [{ type: Input }],
        autofocusFixSmartEmptyCheck: [{ type: Input }],
        autofocusFixTriggerDetectChanges: [{ type: Input }],
        autofocusFixAsync: [{ type: Input }]
    };
    return AutofocusFixDirective;
}());
export { AutofocusFixDirective };
if (false) {
    /**
     * Raw value. Always have default value: ''
     * @type {?}
     */
    AutofocusFixDirective.prototype.autofocus;
    /**
     * @see {\@link AutofocusFixConfig.smartEmptyCheck}
     * @type {?}
     */
    AutofocusFixDirective.prototype.autofocusFixSmartEmptyCheck;
    /**
     * @see {\@link AutofocusFixConfig.triggerDetectChanges}
     * @type {?}
     */
    AutofocusFixDirective.prototype.autofocusFixTriggerDetectChanges;
    /**
     * @see {\@link AutofocusFixConfig.async}
     * @type {?}
     */
    AutofocusFixDirective.prototype.autofocusFixAsync;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.wasInitialized;
    /**
     * Notice: protected for unit testing
     * @type {?}
     * @protected
     */
    AutofocusFixDirective.prototype.localConfig;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.config;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.autofocusEnabled;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.element;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.$cdr;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.$document;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.$config;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b2ZvY3VzLWZpeC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtYXV0b2ZvY3VzLWZpeC8iLCJzb3VyY2VzIjpbImxpYi9hdXRvZm9jdXMtZml4LmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUVMLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsVUFBVSxFQUNWLE1BQU0sRUFDTixLQUFLLEdBR04sTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRTNDLE9BQU8sRUFBRSx1QkFBdUIsRUFBMkIsTUFBTSxTQUFTLENBQUM7QUFDM0UsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlDNUQ7SUE0QkUsK0JBQ0UsR0FBZSxFQUNFLElBQXVCLEVBRXZCLFNBQW1CLEVBQ25CLE9BQTJCO1FBSDNCLFNBQUksR0FBSixJQUFJLENBQW1CO1FBRXZCLGNBQVMsR0FBVCxTQUFTLENBQVU7UUFDbkIsWUFBTyxHQUFQLE9BQU8sQ0FBb0I7UUFadEMsbUJBQWMsR0FBRyxLQUFLLENBQUM7Ozs7UUFFckIsZ0JBQVcsR0FBdUMsRUFBRSxDQUFDO1FBRXZELHFCQUFnQixHQUFHLEtBQUssQ0FBQztRQVUvQixJQUFJLENBQUMsT0FBTyxHQUFHLEdBQUcsQ0FBQyxhQUFhLENBQUM7SUFDbkMsQ0FBQzs7Ozs7SUFFTSwyQ0FBVzs7OztJQUFsQixVQUFtQixPQUFnRTtRQUNqRiw4RkFBOEY7UUFDOUYsSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQUUsT0FBTztTQUFFO1FBRXBDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFDbEUsSUFBSSxDQUFDLHdCQUF3QixDQUFDLGlCQUFpQixFQUFFLE9BQU8s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Ozs7SUFFL0IsNENBQStEOzs7OztJQUMvRCx1Q0FBNkM7Ozs7O0lBQzdDLGlEQUFpQzs7Ozs7SUFDakMsd0NBQXNDOzs7OztJQUlwQyxxQ0FBd0M7Ozs7O0lBQ3hDLDBDQUNvQzs7Ozs7SUFDcEMsd0NBQTRDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLCBPbkluaXQsXG4gIFNpbXBsZUNoYW5nZSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7IG5vcm1hbGl6ZUlucHV0QXNCb29sZWFuLCBNdXRhYmxlUGFydGlhbCwgTXV0YWJsZSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgQXV0b2ZvY3VzRml4Q29uZmlnIH0gZnJvbSAnLi9hdXRvZm9jdXMtZml4LWNvbmZpZyc7XG5cbi8vIEB0b2RvOiBjaGVjayBjb25maWd1cmF0aW9uXG5cbi8qKlxuICogIyMgV2F5cyB0byB0dXJuIG9mZiBhdXRvZm9jdXM6IGFueSBqcy1mYWxzZWx5IHZhbHVlLCBleGNlcHQgZW1wdHkgc3RyaW5nXG4gKlxuICogICAgIDwhLS0gd2l0aCBkYXRhIGJpbmRpbmcgLS0+XG4gKiAgICAgPGlucHV0IFthdXRvZm9jdXNdPVwiXCI+IDwhLS0gdW5kZWZpbmVkIHZhbHVlIC0tPlxuICogICAgIDxpbnB1dCBbYXV0b2ZvY3VzXT1cInVuZGVmaW5lZFwiPlxuICogICAgIDxpbnB1dCBbYXV0b2ZvY3VzXT1cImZhbHNlXCI+XG4gKiAgICAgPGlucHV0IFthdXRvZm9jdXNdPVwibnVsbFwiPlxuICogICAgIDxpbnB1dCBbYXV0b2ZvY3VzXT1cIjBcIj5cbiAqICAgICA8aW5wdXQgW2F1dG9mb2N1c109XCJOYU5cIj5cbiAqXG4gKiAgICAgPCEtLSB3aXRob3V0IGRhdGEgYmluZGluZyAtLT5cbiAqICAgICA8aW5wdXQgYXV0b2ZvY3VzPVwidW5kZWZpbmVkXCI+XG4gKiAgICAgPGlucHV0IGF1dG9mb2N1cz1cImZhbHNlXCI+XG4gKiAgICAgPGlucHV0IGF1dG9mb2N1cz1cIm51bGxcIj5cbiAqICAgICA8aW5wdXQgYXV0b2ZvY3VzPVwiMFwiPlxuICogICAgIDxpbnB1dCBhdXRvZm9jdXM9XCJOYU5cIj5cbiAqXG4gKiAgICAgPGlucHV0PiA8IS0tIGRpc2FibGVkIGJ5IGRlZmF1bHQgLS0+XG4gKlxuICpcbiAqICMjIFdheXMgdG8gZW5hYmxlIGF1dG9mb2N1czogYW55IGpzLXRydWUgdmFsdWUgYW5kIGVtcHR5IHN0cmluZ1xuICpcbiAqICAgICA8IS0tIGVtcHR5IHN0cmluZyB3aWxsIGVuYWJsZSBhdXRvZm9jdXMsIHRoaXMgaXMgZGVmYXVsdCBodG1sIGJlaGF2aW9yIC0tPlxuICogICAgIDxpbnB1dCBbYXV0b2ZvY3VzXT1cIicnXCI+XG4gKiAgICAgPGlucHV0IGF1dG9mb2N1cz1cIlwiPlxuICogICAgIDxpbnB1dCBhdXRvZm9jdXM+XG4gKlxuICogICAgIDxpbnB1dCBbYXV0b2ZvY3VzXT1cInRydWVcIj5cbiAqICAgICA8aW5wdXQgYXV0b2ZvY3VzPVwidHJ1ZVwiPlxuICpcbiAqICAgICA8aW5wdXQgW2F1dG9mb2N1c109XCInYW55IG90aGVyIHZhbHVlcydcIj5cbiAqXG4gKiBAZHluYW1pY1xuICogTm90aWNlOiBAZHluYW1pYyB1c2VkIGZvciBjb3JyZWN0bHkgRG9jdW1lbnQgaW5qZWN0XG4gKiAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzIwMzUxXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1thdXRvZm9jdXNdJyxcbn0pXG5leHBvcnQgY2xhc3MgQXV0b2ZvY3VzRml4RGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkluaXQsIEFmdGVyQ29udGVudEluaXQge1xuXG4gIC8qKiBSYXcgdmFsdWUuIEFsd2F5cyBoYXZlIGRlZmF1bHQgdmFsdWU6ICcnICovXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBhdXRvZm9jdXM6IGFueTtcblxuICAvKiogQHNlZSB7QGxpbmsgQXV0b2ZvY3VzRml4Q29uZmlnLnNtYXJ0RW1wdHlDaGVja30gKi9cbiAgQElucHV0KClcbiAgcHVibGljIGF1dG9mb2N1c0ZpeFNtYXJ0RW1wdHlDaGVjaz86IGJvb2xlYW4gfCBhbnk7XG5cbiAgLyoqIEBzZWUge0BsaW5rIEF1dG9mb2N1c0ZpeENvbmZpZy50cmlnZ2VyRGV0ZWN0Q2hhbmdlc30gKi9cbiAgQElucHV0KClcbiAgcHVibGljIGF1dG9mb2N1c0ZpeFRyaWdnZXJEZXRlY3RDaGFuZ2VzPzogYm9vbGVhbiB8IGFueTtcblxuICAvKiogQHNlZSB7QGxpbmsgQXV0b2ZvY3VzRml4Q29uZmlnLmFzeW5jfSAqL1xuICBASW5wdXQoKVxuICBwdWJsaWMgYXV0b2ZvY3VzRml4QXN5bmM/OiBib29sZWFuIHwgYW55O1xuXG4gIHByaXZhdGUgd2FzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgLyoqIE5vdGljZTogcHJvdGVjdGVkIGZvciB1bml0IHRlc3RpbmcgKi9cbiAgcHJvdGVjdGVkIGxvY2FsQ29uZmlnOiBNdXRhYmxlUGFydGlhbDxBdXRvZm9jdXNGaXhDb25maWc+ID0ge307XG4gIHByaXZhdGUgY29uZmlnITogTXV0YWJsZTxBdXRvZm9jdXNGaXhDb25maWc+O1xuICBwcml2YXRlIGF1dG9mb2N1c0VuYWJsZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSByZWFkb25seSBlbGVtZW50OiBIVE1MRWxlbWVudDtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgJGVyOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgJGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQEluamVjdChET0NVTUVOVClcbiAgICBwcml2YXRlIHJlYWRvbmx5ICRkb2N1bWVudDogRG9jdW1lbnQsXG4gICAgcHJpdmF0ZSByZWFkb25seSAkY29uZmlnOiBBdXRvZm9jdXNGaXhDb25maWcsXG4gICkge1xuICAgIHRoaXMuZWxlbWVudCA9ICRlci5uYXRpdmVFbGVtZW50O1xuICB9XG5cbiAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHsgW2tleSBpbiBrZXlvZiBBdXRvZm9jdXNGaXhEaXJlY3RpdmVdPzogU2ltcGxlQ2hhbmdlIH0pOiB2b2lkIHtcbiAgICAvLyBBdXRvZm9jdXMgd29ya3Mgb25seSBvbmNlLiBObyBuZWVkIHRvIGRvIHRoZSBpbml0aWFsaXphdGlvbiBvbiBlYWNoIGNoYW5nZSBkZXRlY3Rpb24gY3ljbGUuXG4gICAgaWYgKHRoaXMud2FzSW5pdGlhbGl6ZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLm5vcm1hbGl6ZUxvY2FsQ29uZmlnSXRlbSgnYXN5bmMnLCBjaGFuZ2VzLmF1dG9mb2N1c0ZpeEFzeW5jKTtcbiAgICB0aGlzLm5vcm1hbGl6ZUxvY2FsQ29uZmlnSXRlbSgnc21hcnRFbXB0eUNoZWNrJywgY2hhbmdlcy5hdXRvZm9jdXNGaXhTbWFydEVtcHR5Q2hlY2spO1xuICAgIHRoaXMubm9ybWFsaXplTG9jYWxDb25maWdJdGVtKCd0cmlnZ2VyRGV0ZWN0Q2hhbmdlcycsIGNoYW5nZXMuYXV0b2ZvY3VzRml4VHJpZ2dlckRldGVjdENoYW5nZXMpO1xuICB9XG5cbiAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5lbGVtZW50LmZvY3VzKSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKFxuICAgICAgICAnQXV0b2ZvY3VzRml4RGlyZWN0aXZlOiBUaGVyZSBpcyBubyAuZm9jdXMoKSBtZXRob2Qgb24gdGhlIGVsZW1lbnQ6ICVPJyxcbiAgICAgICAgdGhpcy5lbGVtZW50LFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZyA9IHt9IGFzIEF1dG9mb2N1c0ZpeENvbmZpZztcbiAgICBBdXRvZm9jdXNGaXhDb25maWcua2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBsb2NhbCA9IHRoaXMubG9jYWxDb25maWdba2V5XTtcbiAgICAgIHRoaXMuY29uZmlnW2tleV0gPSBsb2NhbCAhPT0gdW5kZWZpbmVkID8gbG9jYWwgOiB0aGlzLiRjb25maWdba2V5XTtcbiAgICB9KTtcblxuICAgIHRoaXMuYXV0b2ZvY3VzRW5hYmxlZCA9IG5vcm1hbGl6ZUlucHV0QXNCb29sZWFuKHRoaXMuYXV0b2ZvY3VzLCB0aGlzLmNvbmZpZy5zbWFydEVtcHR5Q2hlY2spO1xuICB9XG5cbiAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLndhc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuZWxlbWVudC5mb2N1cykgeyByZXR1cm47IH1cblxuICAgIHRoaXMuY2hlY2tGb2N1cygpO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0ZvY3VzKCk6IHZvaWQge1xuICAgIHRoaXMuY29uZmlnLmFzeW5jID8gc2V0VGltZW91dCh0aGlzLmNoZWNrRm9jdXNJbnRlcm5hbC5iaW5kKHRoaXMpKSA6IHRoaXMuY2hlY2tGb2N1c0ludGVybmFsKCk7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrRm9jdXNJbnRlcm5hbCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuYXV0b2ZvY3VzRW5hYmxlZCB8fCB0aGlzLmFtSUZvY3VzZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLmVsZW1lbnQuZm9jdXMoKTtcbiAgICBpZiAodGhpcy5jb25maWcudHJpZ2dlckRldGVjdENoYW5nZXMpIHtcbiAgICAgIHRoaXMuJGNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXQgYW1JRm9jdXNlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy4kZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5lbGVtZW50O1xuICB9XG5cbiAgcHJpdmF0ZSBub3JtYWxpemVMb2NhbENvbmZpZ0l0ZW0oY29uZmlnS2V5OiBrZXlvZiBBdXRvZm9jdXNGaXhDb25maWcsIGNoYW5nZT86IFNpbXBsZUNoYW5nZSk6IHZvaWQge1xuICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgIHRoaXMubG9jYWxDb25maWdbY29uZmlnS2V5XSA9IG5vcm1hbGl6ZUlucHV0QXNCb29sZWFuKGNoYW5nZS5jdXJyZW50VmFsdWUpO1xuICAgIH1cbiAgfVxuXG59XG4iXX0=