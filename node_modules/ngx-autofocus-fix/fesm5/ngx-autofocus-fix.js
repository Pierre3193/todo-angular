import { Directive, ElementRef, ChangeDetectorRef, Inject, Input, InjectionToken, NgModule, Optional } from '@angular/core';
import { DOCUMENT } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AutofocusFixConfig = /** @class */ (function () {
    function AutofocusFixConfig(config) {
        var _this = this;
        /**
         * In case `true` .focus() events will be wrapped by `setTimeout(() => ...)`.
         *
         * Notice:
         * I'm not sure that the action is a good practice, however this ability added because of next issues:
         * - https://github.com/korniychuk/angular-autofocus-fix/issues/1
         * - https://github.com/spirosikmd/angular2-focus/issues/46
         */
        this.async = false;
        /**
         * In case `true`: treat an empty string, an empty array and an empty object as a falsy value.
         * In case `false`(default): each of these values treats as truthy.
         */
        this.smartEmptyCheck = false;
        /**
         * In case `true`: trigger {\@link ChangeDetectorRef.detectChanges}() after {\@link HTMLElement.focus}().
         *
         * This is helpful in the case when the HTMLElement to which {\@link AutofocusFixDirective} added
         * wrapped by another directive/component that has some binding related to focus of the element.
         * In this case without enabling .triggerChangeDetection option Angular throws ExpressionChangedAfterItHasBeenCheckedError.
         *
         * A striking example is the <mat-form-field> from the Angular Material that wraps <input> control.
         */
        this.triggerDetectChanges = false;
        AutofocusFixConfig.keys
            .filter((/**
         * @param {?} name
         * @return {?}
         */
        function (name) { return config[name] !== undefined; }))
            // @ts-ignore
            .forEach((/**
         * @param {?} name
         * @return {?}
         */
        function (name) { return _this[name] = config[name]; }));
    }
    AutofocusFixConfig.keys = ['async', 'smartEmptyCheck', 'triggerDetectChanges'];
    return AutofocusFixConfig;
}());
if (false) {
    /** @type {?} */
    AutofocusFixConfig.keys;
    /**
     * In case `true` .focus() events will be wrapped by `setTimeout(() => ...)`.
     *
     * Notice:
     * I'm not sure that the action is a good practice, however this ability added because of next issues:
     * - https://github.com/korniychuk/angular-autofocus-fix/issues/1
     * - https://github.com/spirosikmd/angular2-focus/issues/46
     * @type {?}
     */
    AutofocusFixConfig.prototype.async;
    /**
     * In case `true`: treat an empty string, an empty array and an empty object as a falsy value.
     * In case `false`(default): each of these values treats as truthy.
     * @type {?}
     */
    AutofocusFixConfig.prototype.smartEmptyCheck;
    /**
     * In case `true`: trigger {\@link ChangeDetectorRef.detectChanges}() after {\@link HTMLElement.focus}().
     *
     * This is helpful in the case when the HTMLElement to which {\@link AutofocusFixDirective} added
     * wrapped by another directive/component that has some binding related to focus of the element.
     * In this case without enabling .triggerChangeDetection option Angular throws ExpressionChangedAfterItHasBeenCheckedError.
     *
     * A striking example is the <mat-form-field> from the Angular Material that wraps <input> control.
     * @type {?}
     */
    AutofocusFixConfig.prototype.triggerDetectChanges;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @param {?=} smartEmptyCheck
 * @return {?}
 */
function normalizeInputAsBoolean(value, smartEmptyCheck) {
    if (smartEmptyCheck === void 0) { smartEmptyCheck = false; }
    /** @type {?} */
    var isFalse = value === false
        || value === null
        || value === undefined
        || value === 0
        || value === 'false'
        || value === 'null'
        || value === 'undefined'
        || value === '0'
        || (typeof value === 'number' && isNaN(value))
        || value === 'NaN'
        || smartEmptyCheck && (value === '' // Notice: opposite default behavior!
            || value instanceof Array && !value.length
            || value !== null && typeof value === 'object' && !Object.keys(value).length);
    return !isFalse;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @todo: check configuration
/**
 * ## Ways to turn off autofocus: any js-falsely value, except empty string
 *
 *     <!-- with data binding -->
 *     <input [autofocus]=""> <!-- undefined value -->
 *     <input [autofocus]="undefined">
 *     <input [autofocus]="false">
 *     <input [autofocus]="null">
 *     <input [autofocus]="0">
 *     <input [autofocus]="NaN">
 *
 *     <!-- without data binding -->
 *     <input autofocus="undefined">
 *     <input autofocus="false">
 *     <input autofocus="null">
 *     <input autofocus="0">
 *     <input autofocus="NaN">
 *
 *     <input> <!-- disabled by default -->
 *
 *
 * ## Ways to enable autofocus: any js-true value and empty string
 *
 *     <!-- empty string will enable autofocus, this is default html behavior -->
 *     <input [autofocus]="''">
 *     <input autofocus="">
 *     <input autofocus>
 *
 *     <input [autofocus]="true">
 *     <input autofocus="true">
 *
 *     <input [autofocus]="'any other values'">
 *
 * \@dynamic
 * Notice: \@dynamic used for correctly Document inject
 *         https://github.com/angular/angular/issues/20351
 */
var AutofocusFixDirective = /** @class */ (function () {
    function AutofocusFixDirective($er, $cdr, $document, $config) {
        this.$cdr = $cdr;
        this.$document = $document;
        this.$config = $config;
        this.wasInitialized = false;
        /**
         * Notice: protected for unit testing
         */
        this.localConfig = {};
        this.autofocusEnabled = false;
        this.element = $er.nativeElement;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    AutofocusFixDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        // Autofocus works only once. No need to do the initialization on each change detection cycle.
        if (this.wasInitialized) {
            return;
        }
        this.normalizeLocalConfigItem('async', changes.autofocusFixAsync);
        this.normalizeLocalConfigItem('smartEmptyCheck', changes.autofocusFixSmartEmptyCheck);
        this.normalizeLocalConfigItem('triggerDetectChanges', changes.autofocusFixTriggerDetectChanges);
    };
    /**
     * @return {?}
     */
    AutofocusFixDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.element.focus) {
            return console.warn('AutofocusFixDirective: There is no .focus() method on the element: %O', this.element);
        }
        this.config = (/** @type {?} */ ({}));
        AutofocusFixConfig.keys.forEach((/**
         * @param {?} key
         * @return {?}
         */
        function (key) {
            /** @type {?} */
            var local = _this.localConfig[key];
            _this.config[key] = local !== undefined ? local : _this.$config[key];
        }));
        this.autofocusEnabled = normalizeInputAsBoolean(this.autofocus, this.config.smartEmptyCheck);
    };
    /**
     * @return {?}
     */
    AutofocusFixDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.wasInitialized = true;
        if (!this.element.focus) {
            return;
        }
        this.checkFocus();
    };
    /**
     * @private
     * @return {?}
     */
    AutofocusFixDirective.prototype.checkFocus = /**
     * @private
     * @return {?}
     */
    function () {
        this.config.async ? setTimeout(this.checkFocusInternal.bind(this)) : this.checkFocusInternal();
    };
    /**
     * @private
     * @return {?}
     */
    AutofocusFixDirective.prototype.checkFocusInternal = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.autofocusEnabled || this.amIFocused) {
            return;
        }
        this.element.focus();
        if (this.config.triggerDetectChanges) {
            this.$cdr.detectChanges();
        }
    };
    Object.defineProperty(AutofocusFixDirective.prototype, "amIFocused", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.$document.activeElement === this.element;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} configKey
     * @param {?=} change
     * @return {?}
     */
    AutofocusFixDirective.prototype.normalizeLocalConfigItem = /**
     * @private
     * @param {?} configKey
     * @param {?=} change
     * @return {?}
     */
    function (configKey, change) {
        if (change) {
            this.localConfig[configKey] = normalizeInputAsBoolean(change.currentValue);
        }
    };
    AutofocusFixDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[autofocus]',
                },] }
    ];
    /** @nocollapse */
    AutofocusFixDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: AutofocusFixConfig }
    ]; };
    AutofocusFixDirective.propDecorators = {
        autofocus: [{ type: Input }],
        autofocusFixSmartEmptyCheck: [{ type: Input }],
        autofocusFixTriggerDetectChanges: [{ type: Input }],
        autofocusFixAsync: [{ type: Input }]
    };
    return AutofocusFixDirective;
}());
if (false) {
    /**
     * Raw value. Always have default value: ''
     * @type {?}
     */
    AutofocusFixDirective.prototype.autofocus;
    /**
     * @see {\@link AutofocusFixConfig.smartEmptyCheck}
     * @type {?}
     */
    AutofocusFixDirective.prototype.autofocusFixSmartEmptyCheck;
    /**
     * @see {\@link AutofocusFixConfig.triggerDetectChanges}
     * @type {?}
     */
    AutofocusFixDirective.prototype.autofocusFixTriggerDetectChanges;
    /**
     * @see {\@link AutofocusFixConfig.async}
     * @type {?}
     */
    AutofocusFixDirective.prototype.autofocusFixAsync;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.wasInitialized;
    /**
     * Notice: protected for unit testing
     * @type {?}
     * @protected
     */
    AutofocusFixDirective.prototype.localConfig;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.config;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.autofocusEnabled;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.element;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.$cdr;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.$document;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.$config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function noAutofocusFixConfigError() {
    /** @type {?} */
    var moduleName = 'AutofocusFixModule';
    /** @type {?} */
    var configName = 'AutofocusFixConfig';
    throw new Error(moduleName + ": Can't inject " + configName + ".\n\n    Option 1: Use .forRoot() when you importing the module:\n              Do it in case you import " + moduleName + " to the root module of your application.\n\n    @NgModule({\n      ...\n      imports: [\n        ...\n        " + moduleName + ".forRoot(),     // <--- new code\n      ],\n      ...\n    })\n    export class AppModule {}\n\n\n    Option 2: Provide " + configName + " manually providing " + configName + ":\n              Do it in case you want to provide specific config to the one of your lazy loadable modules.\n\n    @NgModule({\n      ...\n      providers: [\n        ...\n        {                                               // <--- new code\n          provide: " + configName + "                   // <---\n          useValue: new " + configName + "({ ... }),    // <---\n        },                                              // <---\n      ],\n      ...\n    })\n    export class AppModule {}\n  ");
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Exists for AoT support
/**
 * @param {?} options
 * @return {?}
 */
function configFactory(options) {
    return new AutofocusFixConfig(options);
}
// Exists for AoT support
/** @type {?} */
var AutofocusFixOptionsInternalToken = new InjectionToken('AutofocusFixOptions');
var AutofocusFixModule = /** @class */ (function () {
    function AutofocusFixModule($config) {
        if (!$config) {
            noAutofocusFixConfigError();
        }
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    AutofocusFixModule.forRoot = /**
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = {}; }
        return {
            ngModule: AutofocusFixModule,
            providers: [
                {
                    provide: AutofocusFixOptionsInternalToken,
                    useValue: options,
                },
                {
                    provide: AutofocusFixConfig,
                    useFactory: configFactory,
                    deps: [AutofocusFixOptionsInternalToken],
                },
            ],
        };
    };
    AutofocusFixModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [AutofocusFixDirective],
                    exports: [AutofocusFixDirective]
                },] }
    ];
    /** @nocollapse */
    AutofocusFixModule.ctorParameters = function () { return [
        { type: AutofocusFixConfig, decorators: [{ type: Optional }] }
    ]; };
    return AutofocusFixModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AutofocusFixConfig, AutofocusFixModule, configFactory as ɵa, AutofocusFixDirective as ɵb };
//# sourceMappingURL=ngx-autofocus-fix.js.map
