{"version":3,"file":"ngx-autofocus-fix.js","sources":["ng://ngx-autofocus-fix/lib/autofocus-fix-config.ts","ng://ngx-autofocus-fix/lib/utils.ts","ng://ngx-autofocus-fix/lib/autofocus-fix.directive.ts","ng://ngx-autofocus-fix/lib/no-autofocus-fix-config.error.ts","ng://ngx-autofocus-fix/lib/autofocus-fix.module.ts"],"sourcesContent":["export class AutofocusFixConfig {\n  public static readonly keys: (keyof AutofocusFixConfig)[] = ['async', 'smartEmptyCheck', 'triggerDetectChanges'];\n\n  public constructor(config: AutofocusFixOptions) {\n    AutofocusFixConfig.keys\n      .filter(name => config[name] !== undefined)\n      // @ts-ignore\n      .forEach(name => this[name] = config[name]);\n  }\n\n  /**\n   * In case `true` .focus() events will be wrapped by `setTimeout(() => ...)`.\n   *\n   * Notice:\n   * I'm not sure that the action is a good practice, however this ability added because of next issues:\n   * - https://github.com/korniychuk/angular-autofocus-fix/issues/1\n   * - https://github.com/spirosikmd/angular2-focus/issues/46\n   */\n  public readonly async: boolean = false;\n  /**\n   * In case `true`: treat an empty string, an empty array and an empty object as a falsy value.\n   * In case `false`(default): each of these values treats as truthy.\n   */\n  public readonly smartEmptyCheck: boolean = false;\n  /**\n   * In case `true`: trigger {@link ChangeDetectorRef.detectChanges}() after {@link HTMLElement.focus}().\n   *\n   * This is helpful in the case when the HTMLElement to which {@link AutofocusFixDirective} added\n   * wrapped by another directive/component that has some binding related to focus of the element.\n   * In this case without enabling .triggerChangeDetection option Angular throws ExpressionChangedAfterItHasBeenCheckedError.\n   *\n   * A striking example is the <mat-form-field> from the Angular Material that wraps <input> control.\n   */\n  public readonly triggerDetectChanges: boolean = false;\n}\n\nexport type AutofocusFixOptions = Partial<AutofocusFixConfig>;\n","export type MutablePartial<T> = { -readonly [K in keyof T]+?: T[K] };\nexport type Mutable<T> = { -readonly [K in keyof T]: T[K] };\n\nexport function normalizeInputAsBoolean(value: any, smartEmptyCheck: boolean = false): boolean {\n  const isFalse = value === false\n               || value === null\n               || value === undefined\n               || value === 0\n               || value === 'false'\n               || value === 'null'\n               || value === 'undefined'\n               || value === '0'\n               || (typeof value === 'number' && isNaN(value))\n               || value === 'NaN'\n               || smartEmptyCheck && (\n                       value === '' // Notice: opposite default behavior!\n                    || value instanceof Array && !value.length\n                    || value !== null && typeof value === 'object' && !Object.keys(value).length\n                  );\n\n  return !isFalse;\n}\n","import {\n  AfterContentInit,\n  ChangeDetectorRef,\n  Directive,\n  ElementRef,\n  Inject,\n  Input,\n  OnChanges, OnInit,\n  SimpleChange,\n} from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n\nimport { normalizeInputAsBoolean, MutablePartial, Mutable } from './utils';\nimport { AutofocusFixConfig } from './autofocus-fix-config';\n\n// @todo: check configuration\n\n/**\n * ## Ways to turn off autofocus: any js-falsely value, except empty string\n *\n *     <!-- with data binding -->\n *     <input [autofocus]=\"\"> <!-- undefined value -->\n *     <input [autofocus]=\"undefined\">\n *     <input [autofocus]=\"false\">\n *     <input [autofocus]=\"null\">\n *     <input [autofocus]=\"0\">\n *     <input [autofocus]=\"NaN\">\n *\n *     <!-- without data binding -->\n *     <input autofocus=\"undefined\">\n *     <input autofocus=\"false\">\n *     <input autofocus=\"null\">\n *     <input autofocus=\"0\">\n *     <input autofocus=\"NaN\">\n *\n *     <input> <!-- disabled by default -->\n *\n *\n * ## Ways to enable autofocus: any js-true value and empty string\n *\n *     <!-- empty string will enable autofocus, this is default html behavior -->\n *     <input [autofocus]=\"''\">\n *     <input autofocus=\"\">\n *     <input autofocus>\n *\n *     <input [autofocus]=\"true\">\n *     <input autofocus=\"true\">\n *\n *     <input [autofocus]=\"'any other values'\">\n *\n * @dynamic\n * Notice: @dynamic used for correctly Document inject\n *         https://github.com/angular/angular/issues/20351\n */\n@Directive({\n  selector: '[autofocus]',\n})\nexport class AutofocusFixDirective implements OnChanges, OnInit, AfterContentInit {\n\n  /** Raw value. Always have default value: '' */\n  @Input()\n  public autofocus: any;\n\n  /** @see {@link AutofocusFixConfig.smartEmptyCheck} */\n  @Input()\n  public autofocusFixSmartEmptyCheck?: boolean | any;\n\n  /** @see {@link AutofocusFixConfig.triggerDetectChanges} */\n  @Input()\n  public autofocusFixTriggerDetectChanges?: boolean | any;\n\n  /** @see {@link AutofocusFixConfig.async} */\n  @Input()\n  public autofocusFixAsync?: boolean | any;\n\n  private wasInitialized = false;\n  /** Notice: protected for unit testing */\n  protected localConfig: MutablePartial<AutofocusFixConfig> = {};\n  private config!: Mutable<AutofocusFixConfig>;\n  private autofocusEnabled = false;\n  private readonly element: HTMLElement;\n\n  public constructor(\n    $er: ElementRef,\n    private readonly $cdr: ChangeDetectorRef,\n    @Inject(DOCUMENT)\n    private readonly $document: Document,\n    private readonly $config: AutofocusFixConfig,\n  ) {\n    this.element = $er.nativeElement;\n  }\n\n  public ngOnChanges(changes: { [key in keyof AutofocusFixDirective]?: SimpleChange }): void {\n    // Autofocus works only once. No need to do the initialization on each change detection cycle.\n    if (this.wasInitialized) { return; }\n\n    this.normalizeLocalConfigItem('async', changes.autofocusFixAsync);\n    this.normalizeLocalConfigItem('smartEmptyCheck', changes.autofocusFixSmartEmptyCheck);\n    this.normalizeLocalConfigItem('triggerDetectChanges', changes.autofocusFixTriggerDetectChanges);\n  }\n\n  public ngOnInit(): void {\n    if (!this.element.focus) {\n      return console.warn(\n        'AutofocusFixDirective: There is no .focus() method on the element: %O',\n        this.element,\n      );\n    }\n\n    this.config = {} as AutofocusFixConfig;\n    AutofocusFixConfig.keys.forEach(key => {\n      const local = this.localConfig[key];\n      this.config[key] = local !== undefined ? local : this.$config[key];\n    });\n\n    this.autofocusEnabled = normalizeInputAsBoolean(this.autofocus, this.config.smartEmptyCheck);\n  }\n\n  public ngAfterContentInit(): void {\n    this.wasInitialized = true;\n    if (!this.element.focus) { return; }\n\n    this.checkFocus();\n  }\n\n  private checkFocus(): void {\n    this.config.async ? setTimeout(this.checkFocusInternal.bind(this)) : this.checkFocusInternal();\n  }\n\n  private checkFocusInternal(): void {\n    if (!this.autofocusEnabled || this.amIFocused) { return; }\n\n    this.element.focus();\n    if (this.config.triggerDetectChanges) {\n      this.$cdr.detectChanges();\n    }\n  }\n\n  private get amIFocused(): boolean {\n    return this.$document.activeElement === this.element;\n  }\n\n  private normalizeLocalConfigItem(configKey: keyof AutofocusFixConfig, change?: SimpleChange): void {\n    if (change) {\n      this.localConfig[configKey] = normalizeInputAsBoolean(change.currentValue);\n    }\n  }\n\n}\n","export function noAutofocusFixConfigError() {\n  const moduleName = 'AutofocusFixModule';\n  const configName = 'AutofocusFixConfig';\n\n  throw new Error(`${ moduleName }: Can't inject ${ configName }.\n\n    Option 1: Use .forRoot() when you importing the module:\n              Do it in case you import ${ moduleName } to the root module of your application.\n\n    @NgModule({\n      ...\n      imports: [\n        ...\n        ${ moduleName }.forRoot(),     // <--- new code\n      ],\n      ...\n    })\n    export class AppModule {}\n\n\n    Option 2: Provide ${ configName } manually providing ${ configName }:\n              Do it in case you want to provide specific config to the one of your lazy loadable modules.\n\n    @NgModule({\n      ...\n      providers: [\n        ...\n        {                                               // <--- new code\n          provide: ${ configName }                   // <---\n          useValue: new ${configName}({ ... }),    // <---\n        },                                              // <---\n      ],\n      ...\n    })\n    export class AppModule {}\n  `);\n}\n","import { InjectionToken, ModuleWithProviders, NgModule, Optional } from '@angular/core';\n\nimport { AutofocusFixConfig, AutofocusFixOptions } from './autofocus-fix-config';\nimport { AutofocusFixDirective } from './autofocus-fix.directive';\nimport { noAutofocusFixConfigError } from './no-autofocus-fix-config.error';\n\n// Exists for AoT support\nexport function configFactory(options: AutofocusFixOptions) {\n  return new AutofocusFixConfig(options);\n}\n// Exists for AoT support\nconst AutofocusFixOptionsInternalToken = new InjectionToken('AutofocusFixOptions');\n\n@NgModule({\n  declarations: [AutofocusFixDirective],\n  exports: [AutofocusFixDirective]\n})\nexport class AutofocusFixModule {\n\n  public constructor(@Optional() $config: AutofocusFixConfig) {\n    if (!$config) {\n      noAutofocusFixConfigError();\n    }\n  }\n\n  public static forRoot(options: AutofocusFixOptions = {}): ModuleWithProviders {\n\n    return {\n      ngModule: AutofocusFixModule,\n      providers: [\n        {\n          provide: AutofocusFixOptionsInternalToken,\n          useValue: options,\n        },\n        {\n          provide: AutofocusFixConfig,\n          useFactory: configFactory,\n          deps: [AutofocusFixOptionsInternalToken],\n        },\n      ],\n    };\n  }\n\n}\n"],"names":[],"mappings":"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"}