{"version":3,"sources":["/home/pierre/todo-angular/node_modules/ngx-autofocus-fix/fesm2015/ngx-autofocus-fix.js"],"names":[],"mappings":"AAAA;;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoPC,mXAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2JD,wLAMC;;;;;;;;;;;;;;kCAIA","file":"ngx-autofocus-fix.js","sourcesContent":["import { Directive, ElementRef, ChangeDetectorRef, Inject, Input, InjectionToken, NgModule, Optional } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass AutofocusFixConfig {\n    /**\n     * @param {?} config\n     */\n    constructor(config) {\n        /**\n         * In case `true` .focus() events will be wrapped by `setTimeout(() => ...)`.\n         *\n         * Notice:\n         * I'm not sure that the action is a good practice, however this ability added because of next issues:\n         * - https://github.com/korniychuk/angular-autofocus-fix/issues/1\n         * - https://github.com/spirosikmd/angular2-focus/issues/46\n         */\n        this.async = false;\n        /**\n         * In case `true`: treat an empty string, an empty array and an empty object as a falsy value.\n         * In case `false`(default): each of these values treats as truthy.\n         */\n        this.smartEmptyCheck = false;\n        /**\n         * In case `true`: trigger {\\@link ChangeDetectorRef.detectChanges}() after {\\@link HTMLElement.focus}().\n         *\n         * This is helpful in the case when the HTMLElement to which {\\@link AutofocusFixDirective} added\n         * wrapped by another directive/component that has some binding related to focus of the element.\n         * In this case without enabling .triggerChangeDetection option Angular throws ExpressionChangedAfterItHasBeenCheckedError.\n         *\n         * A striking example is the <mat-form-field> from the Angular Material that wraps <input> control.\n         */\n        this.triggerDetectChanges = false;\n        AutofocusFixConfig.keys\n            .filter((/**\n         * @param {?} name\n         * @return {?}\n         */\n        name => config[name] !== undefined))\n            // @ts-ignore\n            .forEach((/**\n         * @param {?} name\n         * @return {?}\n         */\n        name => this[name] = config[name]));\n    }\n}\nAutofocusFixConfig.keys = ['async', 'smartEmptyCheck', 'triggerDetectChanges'];\nif (false) {\n    /** @type {?} */\n    AutofocusFixConfig.keys;\n    /**\n     * In case `true` .focus() events will be wrapped by `setTimeout(() => ...)`.\n     *\n     * Notice:\n     * I'm not sure that the action is a good practice, however this ability added because of next issues:\n     * - https://github.com/korniychuk/angular-autofocus-fix/issues/1\n     * - https://github.com/spirosikmd/angular2-focus/issues/46\n     * @type {?}\n     */\n    AutofocusFixConfig.prototype.async;\n    /**\n     * In case `true`: treat an empty string, an empty array and an empty object as a falsy value.\n     * In case `false`(default): each of these values treats as truthy.\n     * @type {?}\n     */\n    AutofocusFixConfig.prototype.smartEmptyCheck;\n    /**\n     * In case `true`: trigger {\\@link ChangeDetectorRef.detectChanges}() after {\\@link HTMLElement.focus}().\n     *\n     * This is helpful in the case when the HTMLElement to which {\\@link AutofocusFixDirective} added\n     * wrapped by another directive/component that has some binding related to focus of the element.\n     * In this case without enabling .triggerChangeDetection option Angular throws ExpressionChangedAfterItHasBeenCheckedError.\n     *\n     * A striking example is the <mat-form-field> from the Angular Material that wraps <input> control.\n     * @type {?}\n     */\n    AutofocusFixConfig.prototype.triggerDetectChanges;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} value\n * @param {?=} smartEmptyCheck\n * @return {?}\n */\nfunction normalizeInputAsBoolean(value, smartEmptyCheck = false) {\n    /** @type {?} */\n    const isFalse = value === false\n        || value === null\n        || value === undefined\n        || value === 0\n        || value === 'false'\n        || value === 'null'\n        || value === 'undefined'\n        || value === '0'\n        || (typeof value === 'number' && isNaN(value))\n        || value === 'NaN'\n        || smartEmptyCheck && (value === '' // Notice: opposite default behavior!\n            || value instanceof Array && !value.length\n            || value !== null && typeof value === 'object' && !Object.keys(value).length);\n    return !isFalse;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// @todo: check configuration\n/**\n * ## Ways to turn off autofocus: any js-falsely value, except empty string\n *\n *     <!-- with data binding -->\n *     <input [autofocus]=\"\"> <!-- undefined value -->\n *     <input [autofocus]=\"undefined\">\n *     <input [autofocus]=\"false\">\n *     <input [autofocus]=\"null\">\n *     <input [autofocus]=\"0\">\n *     <input [autofocus]=\"NaN\">\n *\n *     <!-- without data binding -->\n *     <input autofocus=\"undefined\">\n *     <input autofocus=\"false\">\n *     <input autofocus=\"null\">\n *     <input autofocus=\"0\">\n *     <input autofocus=\"NaN\">\n *\n *     <input> <!-- disabled by default -->\n *\n *\n * ## Ways to enable autofocus: any js-true value and empty string\n *\n *     <!-- empty string will enable autofocus, this is default html behavior -->\n *     <input [autofocus]=\"''\">\n *     <input autofocus=\"\">\n *     <input autofocus>\n *\n *     <input [autofocus]=\"true\">\n *     <input autofocus=\"true\">\n *\n *     <input [autofocus]=\"'any other values'\">\n *\n * \\@dynamic\n * Notice: \\@dynamic used for correctly Document inject\n *         https://github.com/angular/angular/issues/20351\n */\nclass AutofocusFixDirective {\n    /**\n     * @param {?} $er\n     * @param {?} $cdr\n     * @param {?} $document\n     * @param {?} $config\n     */\n    constructor($er, $cdr, $document, $config) {\n        this.$cdr = $cdr;\n        this.$document = $document;\n        this.$config = $config;\n        this.wasInitialized = false;\n        /**\n         * Notice: protected for unit testing\n         */\n        this.localConfig = {};\n        this.autofocusEnabled = false;\n        this.element = $er.nativeElement;\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        // Autofocus works only once. No need to do the initialization on each change detection cycle.\n        if (this.wasInitialized) {\n            return;\n        }\n        this.normalizeLocalConfigItem('async', changes.autofocusFixAsync);\n        this.normalizeLocalConfigItem('smartEmptyCheck', changes.autofocusFixSmartEmptyCheck);\n        this.normalizeLocalConfigItem('triggerDetectChanges', changes.autofocusFixTriggerDetectChanges);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        if (!this.element.focus) {\n            return console.warn('AutofocusFixDirective: There is no .focus() method on the element: %O', this.element);\n        }\n        this.config = (/** @type {?} */ ({}));\n        AutofocusFixConfig.keys.forEach((/**\n         * @param {?} key\n         * @return {?}\n         */\n        key => {\n            /** @type {?} */\n            const local = this.localConfig[key];\n            this.config[key] = local !== undefined ? local : this.$config[key];\n        }));\n        this.autofocusEnabled = normalizeInputAsBoolean(this.autofocus, this.config.smartEmptyCheck);\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this.wasInitialized = true;\n        if (!this.element.focus) {\n            return;\n        }\n        this.checkFocus();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    checkFocus() {\n        this.config.async ? setTimeout(this.checkFocusInternal.bind(this)) : this.checkFocusInternal();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    checkFocusInternal() {\n        if (!this.autofocusEnabled || this.amIFocused) {\n            return;\n        }\n        this.element.focus();\n        if (this.config.triggerDetectChanges) {\n            this.$cdr.detectChanges();\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    get amIFocused() {\n        return this.$document.activeElement === this.element;\n    }\n    /**\n     * @private\n     * @param {?} configKey\n     * @param {?=} change\n     * @return {?}\n     */\n    normalizeLocalConfigItem(configKey, change) {\n        if (change) {\n            this.localConfig[configKey] = normalizeInputAsBoolean(change.currentValue);\n        }\n    }\n}\nAutofocusFixDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[autofocus]',\n            },] }\n];\n/** @nocollapse */\nAutofocusFixDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: ChangeDetectorRef },\n    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: AutofocusFixConfig }\n];\nAutofocusFixDirective.propDecorators = {\n    autofocus: [{ type: Input }],\n    autofocusFixSmartEmptyCheck: [{ type: Input }],\n    autofocusFixTriggerDetectChanges: [{ type: Input }],\n    autofocusFixAsync: [{ type: Input }]\n};\nif (false) {\n    /**\n     * Raw value. Always have default value: ''\n     * @type {?}\n     */\n    AutofocusFixDirective.prototype.autofocus;\n    /**\n     * @see {\\@link AutofocusFixConfig.smartEmptyCheck}\n     * @type {?}\n     */\n    AutofocusFixDirective.prototype.autofocusFixSmartEmptyCheck;\n    /**\n     * @see {\\@link AutofocusFixConfig.triggerDetectChanges}\n     * @type {?}\n     */\n    AutofocusFixDirective.prototype.autofocusFixTriggerDetectChanges;\n    /**\n     * @see {\\@link AutofocusFixConfig.async}\n     * @type {?}\n     */\n    AutofocusFixDirective.prototype.autofocusFixAsync;\n    /**\n     * @type {?}\n     * @private\n     */\n    AutofocusFixDirective.prototype.wasInitialized;\n    /**\n     * Notice: protected for unit testing\n     * @type {?}\n     * @protected\n     */\n    AutofocusFixDirective.prototype.localConfig;\n    /**\n     * @type {?}\n     * @private\n     */\n    AutofocusFixDirective.prototype.config;\n    /**\n     * @type {?}\n     * @private\n     */\n    AutofocusFixDirective.prototype.autofocusEnabled;\n    /**\n     * @type {?}\n     * @private\n     */\n    AutofocusFixDirective.prototype.element;\n    /**\n     * @type {?}\n     * @private\n     */\n    AutofocusFixDirective.prototype.$cdr;\n    /**\n     * @type {?}\n     * @private\n     */\n    AutofocusFixDirective.prototype.$document;\n    /**\n     * @type {?}\n     * @private\n     */\n    AutofocusFixDirective.prototype.$config;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @return {?}\n */\nfunction noAutofocusFixConfigError() {\n    /** @type {?} */\n    const moduleName = 'AutofocusFixModule';\n    /** @type {?} */\n    const configName = 'AutofocusFixConfig';\n    throw new Error(`${moduleName}: Can't inject ${configName}.\n\n    Option 1: Use .forRoot() when you importing the module:\n              Do it in case you import ${moduleName} to the root module of your application.\n\n    @NgModule({\n      ...\n      imports: [\n        ...\n        ${moduleName}.forRoot(),     // <--- new code\n      ],\n      ...\n    })\n    export class AppModule {}\n\n\n    Option 2: Provide ${configName} manually providing ${configName}:\n              Do it in case you want to provide specific config to the one of your lazy loadable modules.\n\n    @NgModule({\n      ...\n      providers: [\n        ...\n        {                                               // <--- new code\n          provide: ${configName}                   // <---\n          useValue: new ${configName}({ ... }),    // <---\n        },                                              // <---\n      ],\n      ...\n    })\n    export class AppModule {}\n  `);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Exists for AoT support\n/**\n * @param {?} options\n * @return {?}\n */\nfunction configFactory(options) {\n    return new AutofocusFixConfig(options);\n}\n// Exists for AoT support\n/** @type {?} */\nconst AutofocusFixOptionsInternalToken = new InjectionToken('AutofocusFixOptions');\nclass AutofocusFixModule {\n    /**\n     * @param {?} $config\n     */\n    constructor($config) {\n        if (!$config) {\n            noAutofocusFixConfigError();\n        }\n    }\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n    static forRoot(options = {}) {\n        return {\n            ngModule: AutofocusFixModule,\n            providers: [\n                {\n                    provide: AutofocusFixOptionsInternalToken,\n                    useValue: options,\n                },\n                {\n                    provide: AutofocusFixConfig,\n                    useFactory: configFactory,\n                    deps: [AutofocusFixOptionsInternalToken],\n                },\n            ],\n        };\n    }\n}\nAutofocusFixModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [AutofocusFixDirective],\n                exports: [AutofocusFixDirective]\n            },] }\n];\n/** @nocollapse */\nAutofocusFixModule.ctorParameters = () => [\n    { type: AutofocusFixConfig, decorators: [{ type: Optional }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { AutofocusFixConfig, AutofocusFixModule, configFactory as ɵa, AutofocusFixDirective as ɵb };\n"]}