/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
export class AutofocusFixConfig {
    /**
     * @param {?} config
     */
    constructor(config) {
        /**
         * In case `true` .focus() events will be wrapped by `setTimeout(() => ...)`.
         *
         * Notice:
         * I'm not sure that the action is a good practice, however this ability added because of next issues:
         * - https://github.com/korniychuk/angular-autofocus-fix/issues/1
         * - https://github.com/spirosikmd/angular2-focus/issues/46
         */
        this.async = false;
        /**
         * In case `true`: treat an empty string, an empty array and an empty object as a falsy value.
         * In case `false`(default): each of these values treats as truthy.
         */
        this.smartEmptyCheck = false;
        /**
         * In case `true`: trigger {\@link ChangeDetectorRef.detectChanges}() after {\@link HTMLElement.focus}().
         *
         * This is helpful in the case when the HTMLElement to which {\@link AutofocusFixDirective} added
         * wrapped by another directive/component that has some binding related to focus of the element.
         * In this case without enabling .triggerChangeDetection option Angular throws ExpressionChangedAfterItHasBeenCheckedError.
         *
         * A striking example is the <mat-form-field> from the Angular Material that wraps <input> control.
         */
        this.triggerDetectChanges = false;
        AutofocusFixConfig.keys
            .filter((/**
         * @param {?} name
         * @return {?}
         */
        name => config[name] !== undefined))
            // @ts-ignore
            .forEach((/**
         * @param {?} name
         * @return {?}
         */
        name => this[name] = config[name]));
    }
}
AutofocusFixConfig.keys = ['async', 'smartEmptyCheck', 'triggerDetectChanges'];
if (false) {
    /** @type {?} */
    AutofocusFixConfig.keys;
    /**
     * In case `true` .focus() events will be wrapped by `setTimeout(() => ...)`.
     *
     * Notice:
     * I'm not sure that the action is a good practice, however this ability added because of next issues:
     * - https://github.com/korniychuk/angular-autofocus-fix/issues/1
     * - https://github.com/spirosikmd/angular2-focus/issues/46
     * @type {?}
     */
    AutofocusFixConfig.prototype.async;
    /**
     * In case `true`: treat an empty string, an empty array and an empty object as a falsy value.
     * In case `false`(default): each of these values treats as truthy.
     * @type {?}
     */
    AutofocusFixConfig.prototype.smartEmptyCheck;
    /**
     * In case `true`: trigger {\@link ChangeDetectorRef.detectChanges}() after {\@link HTMLElement.focus}().
     *
     * This is helpful in the case when the HTMLElement to which {\@link AutofocusFixDirective} added
     * wrapped by another directive/component that has some binding related to focus of the element.
     * In this case without enabling .triggerChangeDetection option Angular throws ExpressionChangedAfterItHasBeenCheckedError.
     *
     * A striking example is the <mat-form-field> from the Angular Material that wraps <input> control.
     * @type {?}
     */
    AutofocusFixConfig.prototype.triggerDetectChanges;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b2ZvY3VzLWZpeC1jb25maWcuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtYXV0b2ZvY3VzLWZpeC8iLCJzb3VyY2VzIjpbImxpYi9hdXRvZm9jdXMtZml4LWNvbmZpZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTSxPQUFPLGtCQUFrQjs7OztJQUc3QixZQUFtQixNQUEyQjs7Ozs7Ozs7O1FBZTlCLFVBQUssR0FBWSxLQUFLLENBQUM7Ozs7O1FBS3ZCLG9CQUFlLEdBQVksS0FBSyxDQUFDOzs7Ozs7Ozs7O1FBVWpDLHlCQUFvQixHQUFZLEtBQUssQ0FBQztRQTdCcEQsa0JBQWtCLENBQUMsSUFBSTthQUNwQixNQUFNOzs7O1FBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssU0FBUyxFQUFDO1lBQzNDLGFBQWE7YUFDWixPQUFPOzs7O1FBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFDLENBQUM7SUFDaEQsQ0FBQzs7QUFQc0IsdUJBQUksR0FBaUMsQ0FBQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsc0JBQXNCLENBQUMsQ0FBQzs7O0lBQWpILHdCQUFpSDs7Ozs7Ozs7OztJQWlCakgsbUNBQXVDOzs7Ozs7SUFLdkMsNkNBQWlEOzs7Ozs7Ozs7OztJQVVqRCxrREFBc0QiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgQXV0b2ZvY3VzRml4Q29uZmlnIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBrZXlzOiAoa2V5b2YgQXV0b2ZvY3VzRml4Q29uZmlnKVtdID0gWydhc3luYycsICdzbWFydEVtcHR5Q2hlY2snLCAndHJpZ2dlckRldGVjdENoYW5nZXMnXTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoY29uZmlnOiBBdXRvZm9jdXNGaXhPcHRpb25zKSB7XG4gICAgQXV0b2ZvY3VzRml4Q29uZmlnLmtleXNcbiAgICAgIC5maWx0ZXIobmFtZSA9PiBjb25maWdbbmFtZV0gIT09IHVuZGVmaW5lZClcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIC5mb3JFYWNoKG5hbWUgPT4gdGhpc1tuYW1lXSA9IGNvbmZpZ1tuYW1lXSk7XG4gIH1cblxuICAvKipcbiAgICogSW4gY2FzZSBgdHJ1ZWAgLmZvY3VzKCkgZXZlbnRzIHdpbGwgYmUgd3JhcHBlZCBieSBgc2V0VGltZW91dCgoKSA9PiAuLi4pYC5cbiAgICpcbiAgICogTm90aWNlOlxuICAgKiBJJ20gbm90IHN1cmUgdGhhdCB0aGUgYWN0aW9uIGlzIGEgZ29vZCBwcmFjdGljZSwgaG93ZXZlciB0aGlzIGFiaWxpdHkgYWRkZWQgYmVjYXVzZSBvZiBuZXh0IGlzc3VlczpcbiAgICogLSBodHRwczovL2dpdGh1Yi5jb20va29ybml5Y2h1ay9hbmd1bGFyLWF1dG9mb2N1cy1maXgvaXNzdWVzLzFcbiAgICogLSBodHRwczovL2dpdGh1Yi5jb20vc3Bpcm9zaWttZC9hbmd1bGFyMi1mb2N1cy9pc3N1ZXMvNDZcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBhc3luYzogYm9vbGVhbiA9IGZhbHNlO1xuICAvKipcbiAgICogSW4gY2FzZSBgdHJ1ZWA6IHRyZWF0IGFuIGVtcHR5IHN0cmluZywgYW4gZW1wdHkgYXJyYXkgYW5kIGFuIGVtcHR5IG9iamVjdCBhcyBhIGZhbHN5IHZhbHVlLlxuICAgKiBJbiBjYXNlIGBmYWxzZWAoZGVmYXVsdCk6IGVhY2ggb2YgdGhlc2UgdmFsdWVzIHRyZWF0cyBhcyB0cnV0aHkuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgc21hcnRFbXB0eUNoZWNrOiBib29sZWFuID0gZmFsc2U7XG4gIC8qKlxuICAgKiBJbiBjYXNlIGB0cnVlYDogdHJpZ2dlciB7QGxpbmsgQ2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlc30oKSBhZnRlciB7QGxpbmsgSFRNTEVsZW1lbnQuZm9jdXN9KCkuXG4gICAqXG4gICAqIFRoaXMgaXMgaGVscGZ1bCBpbiB0aGUgY2FzZSB3aGVuIHRoZSBIVE1MRWxlbWVudCB0byB3aGljaCB7QGxpbmsgQXV0b2ZvY3VzRml4RGlyZWN0aXZlfSBhZGRlZFxuICAgKiB3cmFwcGVkIGJ5IGFub3RoZXIgZGlyZWN0aXZlL2NvbXBvbmVudCB0aGF0IGhhcyBzb21lIGJpbmRpbmcgcmVsYXRlZCB0byBmb2N1cyBvZiB0aGUgZWxlbWVudC5cbiAgICogSW4gdGhpcyBjYXNlIHdpdGhvdXQgZW5hYmxpbmcgLnRyaWdnZXJDaGFuZ2VEZXRlY3Rpb24gb3B0aW9uIEFuZ3VsYXIgdGhyb3dzIEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXJyb3IuXG4gICAqXG4gICAqIEEgc3RyaWtpbmcgZXhhbXBsZSBpcyB0aGUgPG1hdC1mb3JtLWZpZWxkPiBmcm9tIHRoZSBBbmd1bGFyIE1hdGVyaWFsIHRoYXQgd3JhcHMgPGlucHV0PiBjb250cm9sLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHRyaWdnZXJEZXRlY3RDaGFuZ2VzOiBib29sZWFuID0gZmFsc2U7XG59XG5cbmV4cG9ydCB0eXBlIEF1dG9mb2N1c0ZpeE9wdGlvbnMgPSBQYXJ0aWFsPEF1dG9mb2N1c0ZpeENvbmZpZz47XG4iXX0=