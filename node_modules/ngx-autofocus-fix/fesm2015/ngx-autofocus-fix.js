import { Directive, ElementRef, ChangeDetectorRef, Inject, Input, InjectionToken, NgModule, Optional } from '@angular/core';
import { DOCUMENT } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AutofocusFixConfig {
    /**
     * @param {?} config
     */
    constructor(config) {
        /**
         * In case `true` .focus() events will be wrapped by `setTimeout(() => ...)`.
         *
         * Notice:
         * I'm not sure that the action is a good practice, however this ability added because of next issues:
         * - https://github.com/korniychuk/angular-autofocus-fix/issues/1
         * - https://github.com/spirosikmd/angular2-focus/issues/46
         */
        this.async = false;
        /**
         * In case `true`: treat an empty string, an empty array and an empty object as a falsy value.
         * In case `false`(default): each of these values treats as truthy.
         */
        this.smartEmptyCheck = false;
        /**
         * In case `true`: trigger {\@link ChangeDetectorRef.detectChanges}() after {\@link HTMLElement.focus}().
         *
         * This is helpful in the case when the HTMLElement to which {\@link AutofocusFixDirective} added
         * wrapped by another directive/component that has some binding related to focus of the element.
         * In this case without enabling .triggerChangeDetection option Angular throws ExpressionChangedAfterItHasBeenCheckedError.
         *
         * A striking example is the <mat-form-field> from the Angular Material that wraps <input> control.
         */
        this.triggerDetectChanges = false;
        AutofocusFixConfig.keys
            .filter((/**
         * @param {?} name
         * @return {?}
         */
        name => config[name] !== undefined))
            // @ts-ignore
            .forEach((/**
         * @param {?} name
         * @return {?}
         */
        name => this[name] = config[name]));
    }
}
AutofocusFixConfig.keys = ['async', 'smartEmptyCheck', 'triggerDetectChanges'];
if (false) {
    /** @type {?} */
    AutofocusFixConfig.keys;
    /**
     * In case `true` .focus() events will be wrapped by `setTimeout(() => ...)`.
     *
     * Notice:
     * I'm not sure that the action is a good practice, however this ability added because of next issues:
     * - https://github.com/korniychuk/angular-autofocus-fix/issues/1
     * - https://github.com/spirosikmd/angular2-focus/issues/46
     * @type {?}
     */
    AutofocusFixConfig.prototype.async;
    /**
     * In case `true`: treat an empty string, an empty array and an empty object as a falsy value.
     * In case `false`(default): each of these values treats as truthy.
     * @type {?}
     */
    AutofocusFixConfig.prototype.smartEmptyCheck;
    /**
     * In case `true`: trigger {\@link ChangeDetectorRef.detectChanges}() after {\@link HTMLElement.focus}().
     *
     * This is helpful in the case when the HTMLElement to which {\@link AutofocusFixDirective} added
     * wrapped by another directive/component that has some binding related to focus of the element.
     * In this case without enabling .triggerChangeDetection option Angular throws ExpressionChangedAfterItHasBeenCheckedError.
     *
     * A striking example is the <mat-form-field> from the Angular Material that wraps <input> control.
     * @type {?}
     */
    AutofocusFixConfig.prototype.triggerDetectChanges;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @param {?=} smartEmptyCheck
 * @return {?}
 */
function normalizeInputAsBoolean(value, smartEmptyCheck = false) {
    /** @type {?} */
    const isFalse = value === false
        || value === null
        || value === undefined
        || value === 0
        || value === 'false'
        || value === 'null'
        || value === 'undefined'
        || value === '0'
        || (typeof value === 'number' && isNaN(value))
        || value === 'NaN'
        || smartEmptyCheck && (value === '' // Notice: opposite default behavior!
            || value instanceof Array && !value.length
            || value !== null && typeof value === 'object' && !Object.keys(value).length);
    return !isFalse;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @todo: check configuration
/**
 * ## Ways to turn off autofocus: any js-falsely value, except empty string
 *
 *     <!-- with data binding -->
 *     <input [autofocus]=""> <!-- undefined value -->
 *     <input [autofocus]="undefined">
 *     <input [autofocus]="false">
 *     <input [autofocus]="null">
 *     <input [autofocus]="0">
 *     <input [autofocus]="NaN">
 *
 *     <!-- without data binding -->
 *     <input autofocus="undefined">
 *     <input autofocus="false">
 *     <input autofocus="null">
 *     <input autofocus="0">
 *     <input autofocus="NaN">
 *
 *     <input> <!-- disabled by default -->
 *
 *
 * ## Ways to enable autofocus: any js-true value and empty string
 *
 *     <!-- empty string will enable autofocus, this is default html behavior -->
 *     <input [autofocus]="''">
 *     <input autofocus="">
 *     <input autofocus>
 *
 *     <input [autofocus]="true">
 *     <input autofocus="true">
 *
 *     <input [autofocus]="'any other values'">
 *
 * \@dynamic
 * Notice: \@dynamic used for correctly Document inject
 *         https://github.com/angular/angular/issues/20351
 */
class AutofocusFixDirective {
    /**
     * @param {?} $er
     * @param {?} $cdr
     * @param {?} $document
     * @param {?} $config
     */
    constructor($er, $cdr, $document, $config) {
        this.$cdr = $cdr;
        this.$document = $document;
        this.$config = $config;
        this.wasInitialized = false;
        /**
         * Notice: protected for unit testing
         */
        this.localConfig = {};
        this.autofocusEnabled = false;
        this.element = $er.nativeElement;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // Autofocus works only once. No need to do the initialization on each change detection cycle.
        if (this.wasInitialized) {
            return;
        }
        this.normalizeLocalConfigItem('async', changes.autofocusFixAsync);
        this.normalizeLocalConfigItem('smartEmptyCheck', changes.autofocusFixSmartEmptyCheck);
        this.normalizeLocalConfigItem('triggerDetectChanges', changes.autofocusFixTriggerDetectChanges);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.element.focus) {
            return console.warn('AutofocusFixDirective: There is no .focus() method on the element: %O', this.element);
        }
        this.config = (/** @type {?} */ ({}));
        AutofocusFixConfig.keys.forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            /** @type {?} */
            const local = this.localConfig[key];
            this.config[key] = local !== undefined ? local : this.$config[key];
        }));
        this.autofocusEnabled = normalizeInputAsBoolean(this.autofocus, this.config.smartEmptyCheck);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.wasInitialized = true;
        if (!this.element.focus) {
            return;
        }
        this.checkFocus();
    }
    /**
     * @private
     * @return {?}
     */
    checkFocus() {
        this.config.async ? setTimeout(this.checkFocusInternal.bind(this)) : this.checkFocusInternal();
    }
    /**
     * @private
     * @return {?}
     */
    checkFocusInternal() {
        if (!this.autofocusEnabled || this.amIFocused) {
            return;
        }
        this.element.focus();
        if (this.config.triggerDetectChanges) {
            this.$cdr.detectChanges();
        }
    }
    /**
     * @private
     * @return {?}
     */
    get amIFocused() {
        return this.$document.activeElement === this.element;
    }
    /**
     * @private
     * @param {?} configKey
     * @param {?=} change
     * @return {?}
     */
    normalizeLocalConfigItem(configKey, change) {
        if (change) {
            this.localConfig[configKey] = normalizeInputAsBoolean(change.currentValue);
        }
    }
}
AutofocusFixDirective.decorators = [
    { type: Directive, args: [{
                selector: '[autofocus]',
            },] }
];
/** @nocollapse */
AutofocusFixDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: AutofocusFixConfig }
];
AutofocusFixDirective.propDecorators = {
    autofocus: [{ type: Input }],
    autofocusFixSmartEmptyCheck: [{ type: Input }],
    autofocusFixTriggerDetectChanges: [{ type: Input }],
    autofocusFixAsync: [{ type: Input }]
};
if (false) {
    /**
     * Raw value. Always have default value: ''
     * @type {?}
     */
    AutofocusFixDirective.prototype.autofocus;
    /**
     * @see {\@link AutofocusFixConfig.smartEmptyCheck}
     * @type {?}
     */
    AutofocusFixDirective.prototype.autofocusFixSmartEmptyCheck;
    /**
     * @see {\@link AutofocusFixConfig.triggerDetectChanges}
     * @type {?}
     */
    AutofocusFixDirective.prototype.autofocusFixTriggerDetectChanges;
    /**
     * @see {\@link AutofocusFixConfig.async}
     * @type {?}
     */
    AutofocusFixDirective.prototype.autofocusFixAsync;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.wasInitialized;
    /**
     * Notice: protected for unit testing
     * @type {?}
     * @protected
     */
    AutofocusFixDirective.prototype.localConfig;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.config;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.autofocusEnabled;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.element;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.$cdr;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.$document;
    /**
     * @type {?}
     * @private
     */
    AutofocusFixDirective.prototype.$config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function noAutofocusFixConfigError() {
    /** @type {?} */
    const moduleName = 'AutofocusFixModule';
    /** @type {?} */
    const configName = 'AutofocusFixConfig';
    throw new Error(`${moduleName}: Can't inject ${configName}.

    Option 1: Use .forRoot() when you importing the module:
              Do it in case you import ${moduleName} to the root module of your application.

    @NgModule({
      ...
      imports: [
        ...
        ${moduleName}.forRoot(),     // <--- new code
      ],
      ...
    })
    export class AppModule {}


    Option 2: Provide ${configName} manually providing ${configName}:
              Do it in case you want to provide specific config to the one of your lazy loadable modules.

    @NgModule({
      ...
      providers: [
        ...
        {                                               // <--- new code
          provide: ${configName}                   // <---
          useValue: new ${configName}({ ... }),    // <---
        },                                              // <---
      ],
      ...
    })
    export class AppModule {}
  `);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Exists for AoT support
/**
 * @param {?} options
 * @return {?}
 */
function configFactory(options) {
    return new AutofocusFixConfig(options);
}
// Exists for AoT support
/** @type {?} */
const AutofocusFixOptionsInternalToken = new InjectionToken('AutofocusFixOptions');
class AutofocusFixModule {
    /**
     * @param {?} $config
     */
    constructor($config) {
        if (!$config) {
            noAutofocusFixConfigError();
        }
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    static forRoot(options = {}) {
        return {
            ngModule: AutofocusFixModule,
            providers: [
                {
                    provide: AutofocusFixOptionsInternalToken,
                    useValue: options,
                },
                {
                    provide: AutofocusFixConfig,
                    useFactory: configFactory,
                    deps: [AutofocusFixOptionsInternalToken],
                },
            ],
        };
    }
}
AutofocusFixModule.decorators = [
    { type: NgModule, args: [{
                declarations: [AutofocusFixDirective],
                exports: [AutofocusFixDirective]
            },] }
];
/** @nocollapse */
AutofocusFixModule.ctorParameters = () => [
    { type: AutofocusFixConfig, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AutofocusFixConfig, AutofocusFixModule, configFactory as ɵa, AutofocusFixDirective as ɵb };
//# sourceMappingURL=ngx-autofocus-fix.js.map
